# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1smusaFoq4VKMYXJCqJosf76VVqAuiEXi
"""

import pandas as pd
import numpy as np


class Analyze:
    def __init__(self):
        self.df = pd.read_csv('Query_Results_2.csv')
        self.ii = self.inverted_index()

        self.tf = self._calculate_tf()
        self.idf = self._calculate_idf()
        self.tfidf = self._calculate_tfidf()

        print(self.tfidf)


    def inverted_index(self) -> dict[str, list[str]]:
        """
        Create an inverted index of the self.df Dataframe.

        Returns:
            Dict[str, List[str]] : A dictionary containing terms as the key and all documents which have the term included as values
        """
        d = {}
        for _, row in self.df.iterrows():
            desc = row['Description']
            desc = desc.split(' ')[:100]
            name = row['Name']
            for token in desc:
                if token not in d:
                    d[token] = [name]
                else:
                    d[token].append(name)

        return d


    def _create_empty_df(self, tf_rows: list[str]) -> pd.DataFrame:
        # Make tokens as columns
        tf_cols = list(self.ii.keys())

        # Init DataFrame
        df = pd.DataFrame(0.0, tf_rows, tf_cols)

        return df


    def _calculate_tf(self) -> pd.DataFrame:
        # Create rows as Name
        tf = self._create_empty_df(self.df['Name'].tolist())

        # Create a dictionary for storing Name and 1 / length of max token frequency
        d_len = {}
        c = 0
        for name in self.df['Name']:
            d_len[name] = 1 / len(
                self.df.loc[c, 'Description'].split(' ')[:100]
            )
            c += 1

        # Iter over inverted_index and add 1/document_length to [doc, term]
        # for each instance of term in a doc
        for term, doc_list in self.ii.items():
            for doc in doc_list:
                tf.at[doc, term] += d_len[doc]

        return tf


    def _calculate_idf(self) -> pd.DataFrame:
        idf = self._create_empty_df(['IDF'])
        total_docs = len(self.df)

        unique_docs = set()
        for term, doc_list in self.ii.items():
            if len(doc_list) == 0:
                idf.at['IDF', term] = 0
                continue

            unique_docs.clear()
            unique_docs.update(doc_list)

            result = np.log(total_docs/len(unique_docs))
            idf.at['IDF', term] = result

        return idf


    def _calculate_tfidf(self) -> pd.DataFrame:
        # Multiply columns of tf with same column of idf
        return self.tf * self.idf.values


a = Analyze()

# Multiply by salary multiplier
for idx, row in a.df.iterrows():
    name = row['Name']
    mult = row['max_yearly_salary'] / 10000
    a.tfidf.iloc[idx] *= mult

sum_df = pd.DataFrame(a.tfidf.sum()).transpose()
sum_df.index = ['sum']

top_50_terms = sum_df.T.nlargest(200, 'sum')

# To csv

top_50_terms.to_csv('topterms.csv')